{
  "hash": "1c7e539abf85096263b3468e7edf69a9",
  "result": {
    "markdown": "---\ntitle: \"chatGPT\"\nsubtitle: \"번역(영한, 한영)\"\ndescription: | \n  데이터 과학 프롬프트 및 GPT 번역결과를 평가합니다.\nauthor:\n  - name: 이광춘\n    url: https://www.linkedin.com/in/kwangchunlee/\n    affiliation: 한국 R 사용자회\n    affiliation-url: https://github.com/bit2r\ntitle-block-banner: true\n#title-block-banner: \"#562457\"\nformat:\n  html:\n    css: css/quarto.css\n    theme: flatly\n    code-fold: false\n    code-overflow: wrap\n    toc: true\n    toc-depth: 3\n    toc-title: 목차\n    number-sections: true\n    highlight-style: github    \n    self-contained: false\nfilters:\n   - lightbox\nlightbox: auto\nlink-citations: true\nknitr:\n  opts_chunk: \n    message: false\n    warning: false\n    collapse: true\n    comment: \"#>\" \n    R.options:\n      knitr.graphics.auto_pdf: true\neditor_options: \n  chunk_output_type: console\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n\n# 번역 지표\n\n**BLEU(Bilingual Evaluation Understudy, 이중 언어 평가 연구)**는 기계 번역의 품질을 평가하는 데 사용되는 지표다. 기계 생성 번역을 사람이 생성한 하나 이상의 참조 번역과 비교하고 참조 번역과 얼마나 유사한지에 따라 점수를 부여하는 방식으로 작동한다. BLEU 점수는 0점에서 1점 사이이며, 1점은 기계 생성 번역과 참조 번역이 완벽하게 일치함을 나타내고, 점수가 높을수록 기계 생성 번역이 참조 번역과 의미적으로 더 가깝다는 것을 의미한다.\n\n**COMET(Cross-lingual Optimized Metric for Evaluation of Translation, 번역 평가를 위한 교차 언어 최적화 지표)**은 2020년에 도입된 기계 번역 평가 지표로 BLEU와 같은 기존 지표의 일부 한계를 해결하기 위해 고안되었다. 기계 생성 번역과 참조 번역 간의 n-그램 중복만을 비교하는 BLEU와 달리 COMET은 유창성, 적절성, 충실도 등 번역 품질에 대한 여러 측면을 고려함은 물론 기계 생성 번역과 참조 번역 간의 의미적 유사성도 고려한다. COMET 점수는 0점에서 100점 사이이며, 점수가 높을수록 기계 생성 번역의 품질이 우수하다는 것을 나타내고, BLEU와 같은 기존 지표보다 사람의 평가와 상관관계가 높은 것으로 나타나 기계 번역 평가에 유망한 지표로 대두되고 있다. \n\n[참고: [@Marie2023translate], [@Marie2023gpt]]{.aside}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprompt = \"Score the following news summarization given the corresponding news with respect to fluency with one to five stars, where one star means “disfluency” and five stars means “perfect fluency”. Note that fluency measures the quality of individual sentences, are they well-written and grammatically correct. Consider the quality of individual sentences.\n\nSource: \nTarget: \"\n```\n:::\n\n\n# 헬로월드\n\n가성비가 뛰어나고 빠른 `gpt-3.5-turbo` GPT 모델을 통해 영문을 한글로, 한글을 영어로 번역해보자. \n[Building a Multilingual Translation Tool with OpenAI ChatGPT API](https://medium.com/@kaushaltrivedi/building-a-multilingual-translation-tool-with-openai-chatgpt-api-84922c971e95) 코드를 일부 변형하여 `reticulate`를 사용해서 번역결과를 목저에 맞게 변형한다.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport openai\n\nopenai.api_key = os.environ.get('OPENAI_API_KEY')\n\ndef translate_text(text, source_language, target_language):\n    prompt = f\"Translate the following '{source_language}' text to '{target_language}': {text}\"\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant that translates text.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=300,\n        n=1,\n        stop=None,\n        temperature=0.5,\n    )\n    \n    return response\n\n# text = \"Hello, how are you?\"\n# result = translate_text(text, \"English\", \"Korean\")\n# print(result)\n# \n# korean_text = \"안녕하세요, 어떻게 지내세요?\"\n# ko_result = translate_text(korean_text, \"Korean\", \"English\")\n# print(ko_result)\n```\n:::\n\n\n[`library(reticulate)`를 실행해야 함.]{.aside}\n\n::::::: column-page \n::::: columns\n::: column\n\n### 한영 {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenglish_text = \"Hello, how are you?\"\n\neng_result = py$translate_text(english_text, \"English\", \"Korean\")\n\nglue::glue(\"번역 대상(Source): {english_text}\\n\",\n           \"번역 결과(Target): {eng_result['choices'][[1]]$message$content}\\n\",\n           \"요청 토크: {eng_result['usage']$prompt_tokens}\\n\",\n           \"완료 토크: {eng_result['usage']$completion_tokens}\\n\",\n           \"전체 토크: {eng_result['usage']$total_tokens}\\n\")\n#> 번역 대상(Source): Hello, how are you?\n#> 번역 결과(Target): 안녕하세요, 어떻게 지내세요?\n#> 요청 토크: 40\n#> 완료 토크: 16\n#> 전체 토크: 56\n```\n:::\n\n:::\n\n::: column\n### 영한 {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkorean_text = \"안녕하세요, 어떻게 지내세요?\"\n\nko_result = py$translate_text(korean_text, \"Korean\", \"English\")\n\nglue::glue(\"번역 대상(Source): {korean_text}\\n\",\n           \"번역 결과(Target): {ko_result['choices'][[1]]$message$content}\\n\",\n           \"요청 토크: {ko_result['usage']$prompt_tokens}\\n\",\n           \"완료 토크: {ko_result['usage']$completion_tokens}\\n\",\n           \"전체 토크: {ko_result['usage']$total_tokens}\\n\")\n#> 번역 대상(Source): 안녕하세요, 어떻게 지내세요?\n#> 번역 결과(Target): \"Hello, how are you?\"\n#> 요청 토크: 49\n#> 완료 토크: 7\n#> 전체 토크: 56\n```\n:::\n\n:::\n:::::\n:::::::\n\n# 번역 엔진\n\n번역 엔진을 달리하여 번역 품질을 살펴보자.\n`Chat` 모형 대표주자가 `gpt-3.5-turbo`를 꼽을 수 있으며,\nGPT-3 모형에 Fine-Tuning한 것이 `InstructGPT` 모형으로 \nAda, Babbage, Curie, Davinci 순으로 비용도 올라가고 성능도 올라간다.\n\n- Chat API Endpoint: `openai.ChatCompletion.create`\n- InstructGPT API Endpoint: `openai.Completion.create`\n\n## 번역대상 텍스트 생성\n\n데이터 시각화에 자주 인용되는 R 패키지와 사용되는 방법을 물었고 \n`gpt-3.5-turbo`을 사용해서 번역 대상 텍스트로 생성한다.\n\n> What are some popular R packages for data visualization and how are they used? <br>\n> \n> 데이터 시각화를 위해 널리 사용되는 R 패키지에는 어떤 것이 있으며 어떻게 사용되나요?\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprompt = f\"What are some popular R packages for data visualization and how are they used?\"\n\nresponse = openai.ChatCompletion.create(\n    model=\"gpt-3.5-turbo\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a data scientist that mainly uses R programming language.\"},\n        {\"role\": \"user\", \"content\": prompt}\n    ],\n    max_tokens=300,\n    n=1,\n    stop=None,\n    temperature=0.5,\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngpt_turbo_result <- glue::glue(\"{py$response['choices'][[1]]$message$content}\\n\")\ngpt_turbo_result %>% \n  write_lines(\"data/gpt_turbo_result.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngpt_turbo_result <- read_lines(\"data/gpt_turbo_result.txt\")\ncat(str_c(gpt_turbo_result, collapse = \"\\n\"))\n#> There are several popular R libraries for data visualization that are widely used by data scientists. Some of the most popular ones are:\n#> \n#> 1. ggplot2: ggplot2 is a powerful and flexible data visualization library that allows users to create complex and aesthetically pleasing plots. It is based on the grammar of graphics and provides a wide range of customization options.\n#> \n#> 2. lattice: lattice is another popular data visualization library that provides a wide range of high-level plotting functions. It is particularly useful for creating multi-panel plots and is often used for visualizing complex data sets.\n#> \n#> 3. plotly: plotly is a web-based data visualization library that allows users to create interactive and dynamic plots. It is particularly useful for creating interactive dashboards and visualizations that can be shared online.\n#> \n#> 4. ggvis: ggvis is a data visualization library that is based on the grammar of graphics and provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive plots that can be used in web applications.\n#> \n#> 5. rCharts: rCharts is a data visualization library that provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive visualizations that can be embedded in web applications.\n#> \n#> These libraries are used to create a wide range of visualizations such as scatter plots, line charts, bar charts, histograms, heatmaps, and more. They provide a wide range of customization options and allow users to create visually appealing and informative plots that can help to communicate complex data sets\n```\n:::\n\n\n## GPT 엔진\n\n### `gpt-3.5-turbo`\n\n`gpt-3.5-turbo`는 속도가 빠르고 저렴하지만 `gpt-4`에는 성능이 미치지 못한다.\nChat모형 `gpt-3.5-turbo` 엔진에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwith open('data/gpt_turbo_result.txt', 'r') as file:\n    source_text = file.read()\n\ndef translate_text_by_model(text, model, source_language, target_language):\n    prompt = f\"Translate the following '{source_language}' text to '{target_language}': {text}\"\n\n    response = openai.ChatCompletion.create(\n        model=model,\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant that translates text.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=1000,\n        n=1,\n        stop=None,\n        temperature=0.5,\n    )\n\n    return response\n\ntranslated_text = translate_text_by_model(source_text, 'gpt-3.5-turbo', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngpt_turbo_3 <- glue::glue(\"{py$translated_text['choices'][[1]]$message$content}\\n\")\ngpt_turbo_3 %>% \n  write_lines(\"data/gpt_turbo_3.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngpt_turbo_3 <- read_lines(\"data/gpt_turbo_3.txt\")\ncat(str_c(gpt_turbo_3, collapse = \"\\n\"))\n#> 데이터 과학자들이 널리 사용하는 데이터 시각화를 위한 인기 있는 R 라이브러리가 몇 가지 있습니다. 가장 인기 있는 것 중 일부는 다음과 같습니다:\n#> \n#> 1. ggplot2: ggplot2는 복잡하고 미학적으로 매력적인 플롯을 만들 수 있게 해주는 강력하고 유연한 데이터 시각화 라이브러리입니다. 그래픽 문법에 기반을 두고 있으며 다양한 사용자 정의 옵션을 제공합니다.\n#> \n#> 2. lattice: lattice는 다양한 고수준 플로팅 함수를 제공하는 인기 있는 데이터 시각화 라이브러리입니다. 특히 멀티 패널 플롯을 만드는 데 유용하며 복잡한 데이터 세트를 시각화하는 데 자주 사용됩니다.\n#> \n#> 3. plotly: plotly는 사용자가 대화형 및 동적 플롯을 만들 수 있는 웹 기반 데이터 시각화 라이브러리입니다. 대화형 대시 보드 및 온라인 공유 가능한 시각화를 만드는 데 특히 유용합니다.\n#> \n#> 4. ggvis: ggvis는 그래픽 문법을 기반으로하며 대화형 및 동적 플롯의 다양한 기능을 제공하는 데이터 시각화 라이브러리입니다. 특히 웹 애플리케이션에서 사용할 수 있는 대화형 플롯을 만드는 데 유용합니다.\n#> \n#> 5. rCharts: rCharts는 다양한 대화형 및 동적 플롯을 제공하는 데이터 시각화 라이브러리입니다. 특히 웹 애플리케이션에 포함될 수 있는 대화형 시각화를 만드는 데 유용합니다.\n#> \n#> 이러한 라이브러리는 산점도, 꺾은 선 그래프, 막대 그래프, 히스토그램, 히트맵 등 다양한 시각화를 만드는 데 사용됩니다. 다양한 사용자 정의 옵션을 제공하며 복잡한 데이터 세트를 전달하는 데 도움이 되는 시각적으로 매력적이고 정보성 있는 플롯을 만들 수 있습니다.\n```\n:::\n\n\n### `text-davinci-003`\n\nInstructGPT `text-davinci-003` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwith open('data/gpt_turbo_result.txt', 'r') as file:\n    source_text = file.read()\n\ndef translate_by_instruct_model(text, model, source_language, target_language):\n    prompt = f\"Translate the following '{source_language}' text to '{target_language}': {text}\"\n\n    response = openai.Completion.create(\n        model=model,\n        prompt=prompt,\n        max_tokens=2000,\n        n=1,\n        temperature=0,\n    )\n\n    return response\n\ndavinci_text = translate_by_instruct_model(source_text, 'text-davinci-003', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_text <- glue::glue(\"{py$davinci_text['choices'][[1]]$text}\\n\")\ndavinci_text %>% \n  write_lines(\"data/davinci_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_text <- read_lines(\"data/davinci_text.txt\")\ncat(str_c(davinci_text, collapse = \"\\n\"))\n#> \n#> 데이터 시각화를 위해 널리 사용되는 인기있는 R 라이브러리가 여러 개 있습니다. 가장 인기있는 것들 중 몇 가지는 다음과 같습니다.\n#> \n#> 1. ggplot2 : ggplot2은 강력하고 유연한 데이터 시각화 라이브러리로, 사용자가 복잡하고 아름다운 그래프를 만들 수 있습니다. 그래프의 문법을 기반으로 하며 다양한 사용자 정의 옵션을 제공합니다.\n#> \n#> 2. lattice : lattice는 다른 인기있는 데이터 시각화 라이브러리로, 다양한 고수준 그래프 기능을 제공합니다. 다중 패널 그래프를 만들 때 특히 유용하며, 복잡한 데이터 세트를 시각화하는 데 자주 사용됩니다.\n#> \n#> 3. plotly : plotly은 웹 기반 데이터 시각화 라이브러리로, 사용자가 상호 작용적이고 동적인 그래프를 만들 수 있습니다. 상호 작용적인 대시 보드 및 온라인으로 공유할 수 있는 시각화를 만들 때 특히 유용합니다.\n#> \n#> 4. ggvis : ggvis는 그래프의 문법을 기반으로한 데이터 시각화 라이브러리로, 다양한 상호 작용적이고 동적인 그래프를 제공합니다. 웹 응용 프로그램에서 사용할 수있는 상호 작용적인 그래프를 만들 때 특히 유용합니다.\n#> \n#> 5. rCharts : rCharts는 다양한 상호 작용적이고 동적인 그래프를 제공하는 데이터 시각화 라이브러리입니다. 웹 응용 프로그램에 통합할 수있는 상호 작용적인 시각화를 만들 때 특히 유용합니다.\n#> \n#> 이러한 라이브러리는 산점도, 선 그래프, 막대 그래프, 히스토그램, 히트맵 등 다양한 시각화를 만들기 위해 사용됩니다. 이들은 다양한 사용자 정의 옵션을 제공하고, 사용자가 복잡한 데이터 세트를 전달하기 위해 아름다운 그래프를 만들 수 있도록 합니다.\n```\n:::\n\n\n\n### `text-curie-001`\n\nInstructGPT `text-curie-001` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef translate_by_instruct_model(text, model, source_language, target_language):\n    prompt = f\"Translate the following '{source_language}' text to '{target_language}': {text}\"\n\n    response = openai.Completion.create(\n        model=model,\n        prompt=prompt,\n        max_tokens=1500,\n        n=1,\n        temperature=0,\n    )\n\n    return response\n  \ncurie_text = translate_by_instruct_model(source_text, 'text-curie-001', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncurie_text <- glue::glue(\"{py$curie_text['choices'][[1]]$text}\\n\")\ncurie_text %>% \n  write_lines(\"data/curie_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncurie_text <- read_lines(\"data/curie_text.txt\")\ncat(str_c(curie_text, collapse = \"\\n\"))\n#> \n#> There are several popular R libraries for data visualization that are widely used by data scientists. Some of the most popular ones are:\n#> \n#> 1. ggplot2: ggplot2 is a powerful and flexible data visualization library that allows users to create complex and aesthetically pleasing plots. It is based on the grammar of graphics and provides a wide range of customization options.\n#> \n#> 2. lattice: lattice is another popular data visualization library that provides a wide range of high-level plotting functions. It is particularly useful for creating multi-panel plots and is often used for visualizing complex data sets.\n#> \n#> 3. plotly: plotly is a web-based data visualization library that allows users to create interactive and dynamic plots. It is particularly useful for creating interactive dashboards and visualizations that can be shared online.\n#> \n#> 4. ggvis: ggvis is a data visualization library that is based on the grammar of graphics and provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive plots that can be used in web applications.\n#> \n#> 5. rCharts: rCharts is a data visualization library that provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive visualizations that can be embedded in web applications.\n```\n:::\n\n\n### `text-babbage-001`\n\nInstructGPT `text-babbage-001` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nbabbage_text = translate_by_instruct_model(source_text, 'text-babbage-001', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbabbage_text <- glue::glue(\"{py$babbage_text['choices'][[1]]$text}\\n\")\nbabbage_text %>% \n  write_lines(\"data/babbage_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbabbage_text <- read_lines(\"data/babbage_text.txt\")\ncat(str_c(babbage_text, collapse = \"\\n\"))\n#> \n#> Korean: 사용한 데이터보호사이트 개발사이트\n```\n:::\n\n\n### `text-ada-001`\n\nInstructGPT `text-ada-001` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nada_text = translate_by_instruct_model(source_text, 'text-ada-001', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nada_text <- glue::glue(\"{py$ada_text['choices'][[1]]$text}\\n\")\nada_text %>% \n  write_lines(\"data/ada_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nada_text <- read_lines(\"data/ada_text.txt\")\ncat(str_c(ada_text, collapse = \"\\n\"))\n#> \n#> Korean\n#> \n#> There are several popular R libraries for data visualization that are widely used by data scientists. Some of the most popular ones are:\n#> \n#> 1. ggplot2: ggplot2 is a powerful and flexible data visualization library that allows users to create complex and aesthetically pleasing plots. It is based on the grammar of graphics and provides a wide range of customization options.\n#> \n#> 2. lattice: lattice is another popular data visualization library that provides a wide range of high-level plotting functions. It is particularly useful for creating multi-panel plots and is often used for visualizing complex data sets.\n#> \n#> 3. plotly: plotly is a web-based data visualization library that allows users to create interactive and dynamic plots. It is particularly useful for creating interactive dashboards and visualizations that can be shared online.\n#> \n#> 4. ggvis: ggvis is a data visualization library that is based on the grammar of graphics and provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive plots that can be used in web applications.\n#> \n#> 5. rCharts: rCharts is a data visualization library that provides a wide range of interactive and dynamic plots. It is particularly useful for creating interactive visualizations that are embedded in web applications.\n```\n:::\n\n\n## 챗GPT 추천\n\n::: {.callout-note collapse=\"true\"}\n### Prompt: recommend instructGPT model for english to korean translation {.unnumbered}\n\nSure, for English to Korean translation, you can use the OpenAI model text-davinci-002 or text-davinci-002-instruct-beta. These models have been trained on a large amount of data and are capable of high-quality translation.\n\nTo use these models, you can modify the translate_text_by_model function like this:\n\n```python\ndef translate_text_by_model(text, model=\"text-davinci-002-instruct-beta\", source_language=\"en\", target_language=\"ko\"):\n    prompt = f\"Translate the following '{source_language}' text to '{target_language}': {text}\"\n    response = openai.Completion.create(\n        engine=model,\n        prompt=prompt,\n        max_tokens=2000,\n        n=1,\n        stop=None,\n        temperature=0.5,\n    )\n\n    return response.choices[0].text\n```\n\nHere, we're using the Completion.create function to directly send the prompt to the API, without the need for the messages parameter. The max_tokens parameter controls the maximum number of tokens that the API can return in the response, so you may want to adjust this value based on your needs.\n\nNote that text-davinci-002-instruct-beta is a beta model that supports instruction following. You can use this model to provide additional context to the translation by including step-by-step instructions in the prompt.\n\n:::\n\n### `text-davinci-002`\n\nInstructGPT `text-davinci-002` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndavinci_2_text = translate_by_instruct_model(source_text, 'text-davinci-002', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_2_text <- glue::glue(\"{py$davinci_2_text['choices'][[1]]$text}\\n\")\ndavinci_2_text %>% \n  write_lines(\"data/davinci_2_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_2_text <- read_lines(\"data/davinci_2_text.txt\")\ncat(str_c(davinci_2_text, collapse = \"\\n\"))\n#> \n#> 1. ggplot2: ggplot2는 강력하고 유연한 데이터 시각화 라이브러리로써 사용자들이 복잡하고 아름다운 그래프를 만들 수 있게 해줍니다. 그것은 그래프의 문법에 기반하여 있으며 다양한 커스터마이징 옵션을 제공합니다.\n#> 2. lattice: lattice는 또 다른 인기있는 데이터 시각화 라이브러리로써 다양한 고수준의 그래프 그리기 기능을 제공합니다. 다중 패널 그래프를 만드는데 특히 유용하며, 복잡한 데이터 세트를 시각화하는데 자주 사용됩니다.\n#> 3. plotly: plotly는 웹 기반의 데이터 시각화 라이브러리로써 사용자들이 상호 작용적이고 동적인 그래프를 만들 수 있게 해줍니다. 특히 웹 애플리케이션에서 사용할 수 있는 상호 작용적인 대시보드와 시각화를 만드는데 특히 유용합니다.\n#> 4. ggvis: ggvis는 그래프의 문법에 기반한 데이터 시각화 라이브러리로써 다양한 상호 작용적이고 동적인 그래프를 제공합니다. 특히 웹 애플리케이션에서 사용할 수 있는 상호 작용적인 그래프를 만드는데 특히 유용합니다.\n#> 5. rCharts: rCharts는 다양한 상호 작용적이고 동적인 그래프를 제공하는 데이터 시각화 라이브러리입니다. 특히 웹 애플리케이션에서 사용할 수 있는 상호 작용적인 시각화를 만드는데 특히 유용합니다.\n#> \n#> 이러한 라이브러리들은 산점도, 선 그래프, 막대 그래프, 히스토그램, 히트맵 등 다양한 시각화를 만들기 위해 사용됩니다. 다양한 커스터마이징 옵션을 제공하며, 사용자들이 보기 좋고 정보적인 그래프를 만들어 복잡한 데이터 세\n```\n:::\n\n\n### `davinci-instruct-beta`\n\nInstructGPT `davinci-instruct-beta` 모형에 넣어 번역 품질을 살펴보자.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndavinci_instruct_text = translate_by_instruct_model(source_text, 'davinci-instruct-beta', 'English', 'Korean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_instruct_text <- glue::glue(\"{py$davinci_instruct_text['choices'][[1]]$text}\\n\")\ndavinci_instruct_text %>% \n  write_lines(\"data/davinci_instruct_text.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndavinci_instruct_text <- read_lines(\"data/davinci_instruct_text.txt\")\ncat(str_c(davinci_instruct_text, collapse = \"\\n\"))\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파일을 읽어주세요.\n#> \n#> 여러번째 파\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}